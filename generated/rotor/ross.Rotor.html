<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ross.Rotor &#8212; ross 1.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx_copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_copybutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../_static/ross-logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ross.Rotor.run_modal" href="ross.Rotor.run_modal.html" />
    <link rel="prev" title="ross.MagneticBearingElement" href="../elements/ross.MagneticBearingElement.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/ross-logo.svg"></span>
          ROSS</a>
        <span class="navbar-text navbar-version pull-left"><b>1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../tutorials.html">Tutorial</a></li>
                <li><a href="../../examples.html">Examples</a></li>
                <li><a href="../../api.html">API</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#install-python">Install Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#install-ross">Install ROSS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/tutorial_part_1.html">Tutorial - Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/tutorial_part_2.html">Tutorial - Running Analyzes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/tutorial_part_3.html">Tutorial - Stochastic ROSS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples.html#ross-examples">ROSS Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples.html#fluidflow-examples">FluidFlow Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples.html#stochastic-ross-examples">Stochastic ROSS Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../download.html">Download notebooks</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../api.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../api.html#material">Material</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#elements">Elements</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../api.html#rotor-and-results">Rotor and Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#results">Results</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#feedback-and-contribution">Feedback and Contribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#code-style-black">Code style: Black</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#how-to-contribute-to-ross-using-git">How to contribute to ROSS using git</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#making-new-releases">Making new releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../release_notes.html#version-v1-0-0">Version v1.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../release_notes.html#version-0-4-0">Version 0.4.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../release_notes.html#version-0-3-0">Version 0.3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../release_notes.html#version-0-2-0-beta-release">Version 0.2.0 (beta release)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../release_notes.html#version-0-1-0-alpha-release">Version 0.1.0 (alpha release)</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">ross.Rotor</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../../_sources/generated/rotor/ross.Rotor.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  </div>
<div class=col-md-9 content><div class="section" id="ross-rotor">
<h1>ross.Rotor<a class="headerlink" href="#ross-rotor" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="ross.Rotor">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ross.</span></code><code class="sig-name descname"><span class="pre">Rotor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shaft_elements</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disk_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bearing_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_mass_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rated_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor" title="Permalink to this definition">¶</a></dt>
<dd><p>A rotor object.</p>
<p>This class will create a rotor with the shaft,
disk, bearing and seal elements provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shaft_elements</strong><span class="classifier">list</span></dt><dd><p>List with the shaft elements</p>
</dd>
<dt><strong>disk_elements</strong><span class="classifier">list</span></dt><dd><p>List with the disk elements</p>
</dd>
<dt><strong>bearing_elements</strong><span class="classifier">list</span></dt><dd><p>List with the bearing elements</p>
</dd>
<dt><strong>point_mass_elements: list</strong></dt><dd><p>List with the point mass elements</p>
</dd>
<dt><strong>tag</strong><span class="classifier">str</span></dt><dd><p>A tag for the rotor</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A rotor object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#  Rotor without damping with 2 shaft elements 1 disk and 2 bearings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ross</span> <span class="k">as</span> <span class="nn">rs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">steel</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">steel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">le</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_d</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o_d</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tim0</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">ShaftElement</span><span class="p">(</span><span class="n">le</span><span class="p">,</span> <span class="n">i_d</span><span class="p">,</span> <span class="n">o_d</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">material</span><span class="o">=</span><span class="n">steel</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">shear_effects</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">rotary_inertia</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">gyroscopic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tim1</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">ShaftElement</span><span class="p">(</span><span class="n">le</span><span class="p">,</span> <span class="n">i_d</span><span class="p">,</span> <span class="n">o_d</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">material</span><span class="o">=</span><span class="n">steel</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">shear_effects</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">rotary_inertia</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">gyroscopic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shaft_elm</span> <span class="o">=</span> <span class="p">[</span><span class="n">tim0</span><span class="p">,</span> <span class="n">tim1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">disk0</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">DiskElement</span><span class="o">.</span><span class="n">from_geometry</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">steel</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.28</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stf</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bearing0</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">BearingElement</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kxx</span><span class="o">=</span><span class="n">stf</span><span class="p">,</span> <span class="n">cxx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bearing1</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">BearingElement</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">kxx</span><span class="o">=</span><span class="n">stf</span><span class="p">,</span> <span class="n">cxx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">Rotor</span><span class="p">(</span><span class="n">shaft_elm</span><span class="p">,</span> <span class="p">[</span><span class="n">disk0</span><span class="p">],</span> <span class="p">[</span><span class="n">bearing0</span><span class="p">,</span> <span class="n">bearing1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modal</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_modal</span><span class="p">(</span><span class="n">speed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modal</span><span class="o">.</span><span class="n">wd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
<span class="go">215.3707...</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evalues</strong><span class="classifier">array</span></dt><dd><p>Rotor’s eigenvalues.</p>
</dd>
<dt><strong>evectors</strong><span class="classifier">array</span></dt><dd><p>Rotor’s eigenvectors.</p>
</dd>
<dt><strong>wn</strong><span class="classifier">array</span></dt><dd><p>Rotor’s natural frequencies in rad/s.</p>
</dd>
<dt><strong>wd</strong><span class="classifier">array</span></dt><dd><p>Rotor’s damped natural frequencies in rad/s.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="ross.Rotor.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shaft_elements</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disk_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bearing_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_mass_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rated_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<p class="rubric">Methods</p>
<dl class="py method">
<dt id="ross.Rotor.A">
<code class="sig-name descname"><span class="pre">A</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.A"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.A" title="Permalink to this definition">¶</a></dt>
<dd><p>State space matrix for an instance of a rotor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>speed: float, optional</strong></dt><dd><p>Rotor speed.
Default is 0.</p>
</dd>
<dt><strong>frequency</strong><span class="classifier">float, optional</span></dt><dd><p>Excitation frequency. Default is rotor speed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A</strong><span class="classifier">np.ndarray</span></dt><dd><p>State space matrix for the rotor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">rotor</span><span class="o">.</span><span class="n">A</span><span class="p">()[</span><span class="mi">50</span><span class="p">:</span><span class="mi">56</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([[     0.,  10927.],</span>
<span class="go">       [-10924.,     -0.],</span>
<span class="go">       [  -174.,      0.],</span>
<span class="go">       [    -0.,   -174.],</span>
<span class="go">       [    -0.,  10723.],</span>
<span class="go">       [-10719.,     -0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.C">
<code class="sig-name descname"><span class="pre">C</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.C"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.C" title="Permalink to this definition">¶</a></dt>
<dd><p>Damping matrix for an instance of a rotor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequency</strong><span class="classifier">float</span></dt><dd><p>Excitation frequency.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C0</strong><span class="classifier">np.ndarray</span></dt><dd><p>Damping matrix for the rotor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span><span class="o">.</span><span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">)[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([[0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 0., 0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.G">
<code class="sig-name descname"><span class="pre">G</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.G"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.G" title="Permalink to this definition">¶</a></dt>
<dd><p>Gyroscopic matrix for an instance of a rotor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G0</strong><span class="classifier">np.ndarray</span></dt><dd><p>Gyroscopic matrix for the rotor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span><span class="o">.</span><span class="n">G</span><span class="p">()[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([[ 0.        ,  0.01943344, -0.00022681,  0.        ],</span>
<span class="go">       [-0.01943344,  0.        ,  0.        , -0.00022681],</span>
<span class="go">       [ 0.00022681,  0.        ,  0.        ,  0.0001524 ],</span>
<span class="go">       [ 0.        ,  0.00022681, -0.0001524 ,  0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.K">
<code class="sig-name descname"><span class="pre">K</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.K"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.K" title="Permalink to this definition">¶</a></dt>
<dd><p>Stiffness matrix for an instance of a rotor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequency</strong><span class="classifier">float, optional</span></dt><dd><p>Excitation frequency.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>K0</strong><span class="classifier">np.ndarray</span></dt><dd><p>Stiffness matrix for the rotor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">rotor</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="mi">0</span><span class="p">)[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">1e6</span><span class="p">)</span>
<span class="go">array([[47.,  0.,  0.,  6.],</span>
<span class="go">       [ 0., 46., -6.,  0.],</span>
<span class="go">       [ 0., -6.,  1.,  0.],</span>
<span class="go">       [ 6.,  0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.Kst">
<code class="sig-name descname"><span class="pre">Kst</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.Kst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.Kst" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic stiffness matrix for an instance of a rotor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Kst0</strong><span class="classifier">np.ndarray</span></dt><dd><p>Dynamic stiffness matrix for the rotor.
This matris IS OMEGA dependent
Only useable to the 6 DoF model.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example_6dof</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">rotor</span><span class="o">.</span><span class="n">Kst</span><span class="p">()[:</span><span class="mi">6</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="mf">1e6</span><span class="p">)</span>
<span class="go">array([[     0., -23002.,      0.,   -479.,      0.,      0.],</span>
<span class="go">       [     0.,      0.,      0.,      0.,      0.,      0.],</span>
<span class="go">       [     0.,      0.,      0.,      0.,      0.,      0.],</span>
<span class="go">       [     0.,      0.,      0.,      0.,      0.,      0.],</span>
<span class="go">       [     0.,    479.,      0.,    160.,      0.,      0.],</span>
<span class="go">       [     0.,      0.,      0.,      0.,      0.,      0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.M">
<code class="sig-name descname"><span class="pre">M</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.M"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.M" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass matrix for an instance of a rotor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M0</strong><span class="classifier">np.ndarray</span></dt><dd><p>Mass matrix for the rotor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span><span class="o">.</span><span class="n">M</span><span class="p">()[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([[ 1.42050794,  0.        ,  0.        ,  0.04931719],</span>
<span class="go">       [ 0.        ,  1.42050794, -0.04931719,  0.        ],</span>
<span class="go">       [ 0.        , -0.04931719,  0.00231392,  0.        ],</span>
<span class="go">       [ 0.04931719,  0.        ,  0.        ,  0.00231392]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="id0">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shaft_elements</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disk_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bearing_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_mass_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rated_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.convergence">
<code class="sig-name descname"><span class="pre">convergence</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_eigval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Run convergence analysis.</p>
<p>Function to analyze the eigenvalues convergence through the number of
shaft elements. Every new run doubles the number os shaft elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_eigval</strong><span class="classifier">int</span></dt><dd><p>The nth eigenvalue which the convergence analysis will run.
Default is 0 (the first eigenvalue).</p>
</dd>
<dt><strong>err_max</strong><span class="classifier">float</span></dt><dd><p>Maximum allowable convergence error.
Default is 1e-02</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">An instance of ConvergenceResults class, which is used to post-process</span></dt><dd></dd>
<dt>results. Attributes stored:</dt><dd><dl class="simple">
<dt>el_num<span class="classifier">array</span></dt><dd><p>Array with number of elements in each iteraction</p>
</dd>
<dt>eigv_arr<span class="classifier">array</span></dt><dd><p>Array with the n’th natural frequency in each iteraction</p>
</dd>
<dt>error_arr<span class="classifier">array</span></dt><dd><p>Array with the relative error in each iteraction</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.from_section">
<em class="property"><span class="pre">classmethod</span> </em><code class="sig-name descname"><span class="pre">from_section</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">leng_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idl_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odl_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idr_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">odr_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">material_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disk_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">brg_seal_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rated_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.from_section"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.from_section" title="Permalink to this definition">¶</a></dt>
<dd><p>Build rotor from sections.</p>
<p>This class is an alternative to build rotors from separated
sections. Each section has the same number (n) of shaft elements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>leng_data</strong><span class="classifier">list</span></dt><dd><p>List with the lengths of rotor regions.</p>
</dd>
<dt><strong>idl_data</strong><span class="classifier">list</span></dt><dd><p>List with the inner diameters of rotor regions (Left Station).</p>
</dd>
<dt><strong>odl_data</strong><span class="classifier">list</span></dt><dd><p>List with the outer diameters of rotor regions (Left Station).</p>
</dd>
<dt><strong>idr_data</strong><span class="classifier">list, optional</span></dt><dd><p>List with the inner diameters of rotor regions (Right Station).
Default is equal to idl_data (cylindrical element).</p>
</dd>
<dt><strong>odr_data</strong><span class="classifier">list, optional</span></dt><dd><p>List with the outer diameters of rotor regions (Right Station).
Default is equal to odl_data (cylindrical element).</p>
</dd>
<dt><strong>material_data</strong><span class="classifier">ross.material or list of ross.material</span></dt><dd><p>Defines a single material for all sections or each section can be
defined by a material individually.</p>
</dd>
<dt><strong>disk_data</strong><span class="classifier">dict, optional</span></dt><dd><p>Dict holding disks datas.
Example : disk_data=DiskElement.from_geometry(n=2,</p>
<blockquote>
<div><p>material=steel,
width=0.07,
i_d=0,
o_d=0.28
)</p>
</div></blockquote>
<p><strong>*See ‘disk_element.py’ docstring for more information*</strong></p>
</dd>
<dt><strong>brg_seal_data</strong><span class="classifier">dict, optional</span></dt><dd><p>Dict holding lists of bearings and seals datas.
Example : brg_seal_data=BearingElement(n=1, kxx=1e6, cxx=0,</p>
<blockquote>
<div><p>kyy=1e6, cyy=0, kxy=0,
cxy=0, kyx=0, cyx=0)</p>
</div></blockquote>
<p><strong>*See ‘bearing_seal_element.py’ docstring for more information*</strong></p>
</dd>
<dt><strong>nel_r</strong><span class="classifier">int, optional</span></dt><dd><p>Number or elements per shaft region.
Default is 1.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">str</span></dt><dd><p>A tag for the rotor</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A rotor object</dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Error raised if lists size do not match.</p>
</dd>
<dt>AttributeError</dt><dd><p>Error raised if the shaft material is not defined.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.load">
<em class="property"><span class="pre">classmethod</span> </em><code class="sig-name descname"><span class="pre">load</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.load"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load rotor from toml file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>String or Path for a .toml file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rotor</strong><span class="classifier">ross.rotor.Rotor</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.plot_rotor">
<code class="sig-name descname"><span class="pre">plot_rotor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">nodes=1</span></em>, <em class="sig-param"><span class="pre">check_sld=False</span></em>, <em class="sig-param"><span class="pre">length_units='m'</span></em>, <em class="sig-param"><span class="pre">\*\*kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.plot_rotor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.plot_rotor" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a rotor object.</p>
<p>This function will take a rotor object and plot its elements representation
using Plotly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">int, optional</span></dt><dd><p>Increment that will be used to plot nodes label.</p>
</dd>
<dt><strong>check_sld</strong><span class="classifier">bool</span></dt><dd><p>If True, checks the slenderness ratio for each element.
The shaft elements which has a slenderness ratio &lt; 1.6 will be displayed in
yellow color.</p>
</dd>
<dt><strong>length_units</strong><span class="classifier">str, optional</span></dt><dd><p>length units to length and diameter.
Default is ‘m’.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">optional</span></dt><dd><p>Additional key word arguments can be passed to change the plot layout only
(e.g. width=1000, height=800, …).
<a href="#id1"><span class="problematic" id="id2">*</span></a>See Plotly Python Figure Reference for more information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">plotly.graph_objects.Figure</span></dt><dd><p>The figure object with the rotor representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_campbell">
<code class="sig-name descname"><span class="pre">run_campbell</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'wd'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_campbell"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_campbell" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Campbell diagram.</p>
<p>This function will calculate the damped natural frequencies
for a speed range.</p>
<dl class="simple">
<dt>Available plotting methods:</dt><dd><p>.plot()</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>speed_range</strong><span class="classifier">array</span></dt><dd><p>Array with the speed range in rad/s.</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequencies that will be calculated.
Default is 6.</p>
</dd>
<dt><strong>frequency_type</strong><span class="classifier">str, optional</span></dt><dd><p>Choose between displaying results related to the undamped natural
frequencies (“wn”) or damped natural frequencies (“wd”).
The default is “wd”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">array</span></dt><dd><p>Array with the damped natural frequencies, log dec and precessions
corresponding to each speed of the speed_rad array.
It will be returned if plot=False.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ross</span> <span class="k">as</span> <span class="nn">rs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor1</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
</pre></div>
</div>
<p>Diagram with undamped natural frequencies
&gt;&gt;&gt; camp = rotor1.run_campbell(speed, frequency_type=”wn”)</p>
<p>Diagram with damped natural frequencies
&gt;&gt;&gt; camp = rotor1.run_campbell(speed)</p>
<p>Plotting Campbell Diagram
&gt;&gt;&gt; fig = camp.plot()</p>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_crack">
<code class="sig-name descname"><span class="pre">run_crack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">\*\*kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_crack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_crack" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an analyzes with rubbing.</p>
<p>Execute the crack defect and generates the crack object on the back-end.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs: dictionary</strong></dt><dd><dl class="simple">
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs receives:</dt><dd><dl class="simple">
<dt>dt<span class="classifier">float</span></dt><dd><p>Time step</p>
</dd>
<dt>tI<span class="classifier">float</span></dt><dd><p>Initial time</p>
</dd>
<dt>tF<span class="classifier">float</span></dt><dd><p>Final time</p>
</dd>
<dt>depth_ratio<span class="classifier">float</span></dt><dd><p>Crack depth ratio related to the diameter of the crack container element. A depth value of 0.1 is equal to 10%, 0.2 equal to 20%, and so on.</p>
</dd>
<dt>n_crack<span class="classifier">float</span></dt><dd><p>Element where the crack is located</p>
</dd>
<dt>speed<span class="classifier">float, pint.Quantity</span></dt><dd><p>Operational speed of the machine. Default unit is rad/s.</p>
</dd>
<dt>unbalance_magnitude<span class="classifier">array</span></dt><dd><p>Array with the unbalance magnitude. The unit is kg.m.</p>
</dd>
<dt>unbalance_phase<span class="classifier">array</span></dt><dd><p>Array with the unbalance phase. The unit is rad.</p>
</dd>
<dt>crack_type<span class="classifier">string</span></dt><dd><p>String containing type of crack model chosed. The avaible types are: Mayes and Gasch.</p>
</dd>
<dt>print_progress<span class="classifier">bool</span></dt><dd><p>Set it True, to print the time iterations and the total time spent, by default False.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><strong>Examples</strong></dt><dd></dd>
<dt><strong>——–</strong></dt><dd></dd>
<dt><strong>&gt;&gt;&gt; from ross.defects.crack import crack_example</strong></dt><dd></dd>
<dt><strong>&gt;&gt;&gt; probe1 = (14, 0)</strong></dt><dd></dd>
<dt><strong>&gt;&gt;&gt; probe2 = (22, 0)</strong></dt><dd></dd>
<dt><strong>&gt;&gt;&gt; response = crack_example()</strong></dt><dd></dd>
<dt><strong>&gt;&gt;&gt; results = response.run_time_response()</strong></dt><dd></dd>
<dt><strong>&gt;&gt;&gt; fig = response.plot_dfft(probe=[probe1, probe2], range_freq=[0, 100], yaxis_type=”log”)</strong></dt><dd></dd>
<dt><strong>&gt;&gt;&gt; # fig.show()</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_critical_speed">
<code class="sig-name descname"><span class="pre">run_critical_speed</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_critical_speed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_critical_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the critical speeds and damping ratios for the rotor model.</p>
<p>This function runs an iterative method over “run_modal()” to minimize
(using scipy.optimize.newton) the error between the rotor speed and the rotor
critical speeds (rotor speed - critical speed).</p>
<p>Differently from run_modal(), this function doesn’t take a speed input because
it iterates over the natural frequencies calculated in the last iteration.
The initial value is considered to be the undamped natural frequecies for
speed = 0 (no gyroscopic effect).</p>
<p>Once the error is within an acceptable range defined by “rtol”, it returns the
approximated critical speed.</p>
<p>With the critical speeds calculated, the function uses the results to
calculate the log dec and damping ratios for each critical speed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>speed_range</strong><span class="classifier">tuple</span></dt><dd><p>Tuple (start, end) with the desired range of frequencies (rad/s).
The function returns all eigenvalues within this range.</p>
</dd>
<dt><strong>num_modes</strong><span class="classifier">int, optional</span></dt><dd><p>The number of eigenvalues and eigenvectors to be calculated using ARPACK.
If sparse=True, it determines the number of eigenvalues and eigenvectors
to be calculated. It must be smaller than Rotor.ndof - 1. It is not
possible to compute all eigenvectors of a matrix with ARPACK.
If speed_range is not None, num_modes is overrided.
Default is 12.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance (relative) for termination. Applied to scipy.optimize.newton.
Default is 0.005 (0.5%).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>CriticalSpeedResults</strong><span class="classifier">An instance of CriticalSpeedResults class, which is</span></dt><dd></dd>
<dt>used to post-process results. Attributes stored:</dt><dd><p>CriticalSpeedResults.wn() : undamped critical speeds.
CriticalSpeedResults.wd(): damped critical speeds.
CriticalSpeedResults.log_dec : log_dec for each critical speed.
CriticalSpeedResults.damping_ratio : damping ratio for each critical speed.
CriticalSpeedResults.whirl_direction : whirl dir. for each critical speed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ross</span> <span class="k">as</span> <span class="nn">rs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">rotor_example</span><span class="p">()</span>
</pre></div>
</div>
<p>Finding the first Nth critical speeds
&gt;&gt;&gt; results = rotor.run_critical_speed(num_modes=8)
&gt;&gt;&gt; np.round(results.wd())
array([ 92.,  96., 271., 300.])
&gt;&gt;&gt; np.round(results.wn())
array([ 92.,  96., 271., 300.])</p>
<p>Finding the first critical speeds within a speed range
&gt;&gt;&gt; results = rotor.run_critical_speed(speed_range=(100, 1000))
&gt;&gt;&gt; np.round(results.wd())
array([271., 300., 636., 867.])</p>
<p>Changing output units
&gt;&gt;&gt; np.round(results.wd(“rpm”))
array([2590., 2868., 6074., 8278.])</p>
<p>Retrieving whirl directions
&gt;&gt;&gt; results.whirl_direction # doctest: +ELLIPSIS
array([…</p>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_forced_response">
<code class="sig-name descname"><span class="pre">run_forced_response</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_forced_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_forced_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Forced response for a mdof system.</p>
<p>This method returns the unbalanced response for a mdof system
given magnitude and phase of the unbalance, the node where it’s
applied and a frequency range.</p>
<dl class="simple">
<dt>Available plotting methods:</dt><dd><p>.plot()
.plot_magnitude()
.plot_phase()
.plot_polar_bode()
.plot_deflected_shape()
.plot_bending_moment()
.plot_deflected_shape_3d()
.plot_deflected_shape_2d()</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>force</strong><span class="classifier">list, array</span></dt><dd><p>Unbalance force in each degree of freedom for each value in omega</p>
</dd>
<dt><strong>speed_range</strong><span class="classifier">list, array</span></dt><dd><p>Array with the desired range of frequencies</p>
</dd>
<dt><strong>modes</strong><span class="classifier">list, optional</span></dt><dd><p>Modes that will be used to calculate the frequency response
(all modes will be used if a list is not given).</p>
</dd>
<dt><strong>unbalance</strong><span class="classifier">array, optional</span></dt><dd><p>Array with the unbalance data (node, magnitude and phase) to be plotted
with deflected shape. This argument is set only if running an unbalance
response analysis.
Default is None.</p>
</dd>
<dt><strong>cluster_points</strong><span class="classifier">bool, optional</span></dt><dd><p>boolean to activate the automatic frequency spacing method. If True, the
method uses _clustering_points() to create an speed_range.
Default is False</p>
</dd>
<dt><strong>num_points</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points generated per critical speed.
The method set the same number of points for slightly less and slightly
higher than the natural circular frequency. It means there’ll be num_points
greater and num_points smaller than a given critical speed.
num_points may be between 2 and 12. Anything above this range defaults
to 10 and anything below this range defaults to 4.
The default is 10.</p>
</dd>
<dt><strong>num_modes</strong></dt><dd><p>The number of eigenvalues and eigenvectors to be calculated using ARPACK.
It also defines the range for the output array, since the method generates
points only for the critical speed calculated by run_critical_speed().
Default is 12.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance (relative) for termination. Applied to scipy.optimize.newton to
calculate the approximated critical speeds.
Default is 0.005 (0.5%).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>forced_resp</strong><span class="classifier">object</span></dt><dd><p>An instance of ForcedResponseResult class, which is used to post-process
results. Attributes stored:
forced_resp : array</p>
<blockquote>
<div><p>Array with the forced response for each node for each frequency.</p>
</div></blockquote>
<dl class="simple">
<dt>speed_range<span class="classifier">array</span></dt><dd><p>Array with the frequencies.</p>
</dd>
<dt>velc_resp<span class="classifier">array</span></dt><dd><p>Array with the velocity response for each node for each frequency.</p>
</dd>
<dt>accl_resp<span class="classifier">array</span></dt><dd><p>Array with the acceleration response for each node for each frequency.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">force</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">_unbalance_force</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">speed</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resp</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_forced_response</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">speed_range</span><span class="o">=</span><span class="n">speed</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">forced_resp</span><span class="p">)</span> 
<span class="go">array([[0.00000000e+00, 5.06073311e-04, 2.10044826e-03, ...</span>
</pre></div>
</div>
<p>Using clustered points option.
Set <cite>cluster_points=True</cite> and choose how many modes the method must search and
how many points to add just before and after each critical speed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_forced_response</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">cluster_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">5</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">speed_range</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(61,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_freq_response">
<code class="sig-name descname"><span class="pre">run_freq_response</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_freq_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_freq_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Frequency response for a mdof system.</p>
<p>This method returns the frequency response for a mdof system given a range of
frequencies and the modes that will be used.</p>
<dl class="simple">
<dt>Available plotting methods:</dt><dd><p>.plot()
.plot_magnitude()
.plot_phase()
.plot_polar_bode()</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>speed_range</strong><span class="classifier">array, optional</span></dt><dd><p>Array with the desired range of frequencies.
Default is 0 to 1.5 x highest damped natural frequency.</p>
</dd>
<dt><strong>modes</strong><span class="classifier">list, optional</span></dt><dd><p>Modes that will be used to calculate the frequency response
(all modes will be used if a list is not given).</p>
</dd>
<dt><strong>cluster_points</strong><span class="classifier">bool, optional</span></dt><dd><p>boolean to activate the automatic frequency spacing method. If True, the
method uses _clustering_points() to create an speed_range.
Default is False</p>
</dd>
<dt><strong>num_points</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points generated per critical speed.
The method set the same number of points for slightly less and slightly
higher than the natural circular frequency. It means there’ll be num_points
greater and num_points smaller than a given critical speed.
num_points may be between 2 and 12. Anything above this range defaults
to 10 and anything below this range defaults to 4.
The default is 10.</p>
</dd>
<dt><strong>num_modes</strong></dt><dd><p>The number of eigenvalues and eigenvectors to be calculated using ARPACK.
It also defines the range for the output array, since the method generates
points only for the critical speed calculated by run_critical_speed().
Default is 12.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance (relative) for termination. Applied to scipy.optimize.newton to
calculate the approximated critical speeds.
Default is 0.005 (0.5%).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier">object</span></dt><dd><p>An instance of ForcedResponseResult class, which is used to post-process
results. Attributes stored:
freq_resp : array</p>
<blockquote>
<div><p>Array with the frequency response for each node for each pair
input/output.</p>
</div></blockquote>
<dl class="simple">
<dt>speed_range<span class="classifier">array</span></dt><dd><p>Array with the frequencies.</p>
</dd>
<dt>velc_resp<span class="classifier">array</span></dt><dd><p>Array with the velocity response for each node for each pair
input/output.</p>
</dd>
<dt>accl_resp<span class="classifier">array</span></dt><dd><p>Array with the acceleration response for each node for each pair
input/output.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ross</span> <span class="k">as</span> <span class="nn">rs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_freq_response</span><span class="p">(</span><span class="n">speed_range</span><span class="o">=</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>Return the response amplitude
&gt;&gt;&gt; abs(response.freq_resp) # doctest: +ELLIPSIS
array([[[1.00000000e-06, 1.00261725e-06, 1.01076952e-06, …</p>
<p>Return the response phase
&gt;&gt;&gt; np.angle(response.freq_resp) # doctest: +ELLIPSIS
array([[[…</p>
<p>Using clustered points option.
Set <cite>cluster_points=True</cite> and choose how many modes the method must search and
how many points to add just before and after each critical speed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_freq_response</span><span class="p">(</span><span class="n">cluster_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">speed_range</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(61,)</span>
</pre></div>
</div>
<p>Selecting the disirable modes, if you want a reduced model:
&gt;&gt;&gt; response = rotor.run_freq_response(speed_range=speed, modes=[0, 1, 2])
&gt;&gt;&gt; abs(response.freq_resp) # doctest: +ELLIPSIS
array([[[2.00154633e-07, 2.02422522e-07, 2.09522044e-07, …</p>
<p>Plotting frequency response function:
&gt;&gt;&gt; fig = response.plot(inp=13, out=13)</p>
<p>To plot velocity and acceleration responses, you must change amplitude_units
from “[length]/[force]” units to “[speed]/[force]” or “[acceleration]/[force]”
respectively</p>
<p>Plotting velocity response
&gt;&gt;&gt; fig = response.plot(inp=13, out=13, amplitude_units=”m/s/N”)</p>
<p>Plotting acceleration response
&gt;&gt;&gt; fig = response.plot(inp=13, out=13, amplitude_units=”m/s**2/N”)</p>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_level1">
<code class="sig-name descname"><span class="pre">run_level1</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">n=5</span></em>, <em class="sig-param"><span class="pre">stiffness_range=None</span></em>, <em class="sig-param"><span class="pre">num=5</span></em>, <em class="sig-param"><span class="pre">\*\*kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_level1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_level1" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot level 1 stability analysis.</p>
<p>This method will plot the stability 1 analysis for a
given stiffness range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of steps in the range.
Default is 5.</p>
</dd>
<dt><strong>stiffness_range</strong><span class="classifier">tuple, optional</span></dt><dd><p>Tuple with (start, end) for stiffness range.
This will be used to create an evenly numbers spaced evenly on a log scale
to create a better visualization (see np.logspace).</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">optional</span></dt><dd><p>Additional key word arguments can be passed to change the plot layout only
(e.g. width=1000, height=800, …).
<a href="#id5"><span class="problematic" id="id6">*</span></a>See Plotly Python Figure Reference for more information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Plotly graph_objects.Figure()</span></dt><dd><p>The figure object with the plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_misalignment">
<code class="sig-name descname"><span class="pre">run_misalignment</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">coupling='flex'</span></em>, <em class="sig-param"><span class="pre">\*\*kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_misalignment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_misalignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an analyzes with misalignment.</p>
<p>Execute the misalignment defect and generates the misalignment object
on the back-end. There are two types of coupling, flexible (flex)
and rigid, which have different entries. These entries are provided
via <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs to the specific method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coupling</strong><span class="classifier">str</span></dt><dd><p>Coupling type. The avaible types are: flex, by default; and rigid.</p>
</dd>
<dt><strong>**kwargs: dictionary</strong></dt><dd><dl class="simple">
<dt>In the case of coupling = “flex”, <a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs receives:</dt><dd><dl class="simple">
<dt>dt<span class="classifier">float</span></dt><dd><p>Time step.</p>
</dd>
<dt>tI<span class="classifier">float</span></dt><dd><p>Initial time.</p>
</dd>
<dt>tF<span class="classifier">float</span></dt><dd><p>Final time.</p>
</dd>
<dt>kd<span class="classifier">float</span></dt><dd><p>Radial stiffness of flexible coupling.</p>
</dd>
<dt>ks<span class="classifier">float</span></dt><dd><p>Bending stiffness of flexible coupling.</p>
</dd>
<dt>eCOUPx<span class="classifier">float</span></dt><dd><p>Parallel misalignment offset between driving rotor and driven rotor along X direction.</p>
</dd>
<dt>eCOUPy<span class="classifier">float</span></dt><dd><p>Parallel misalignment offset between driving rotor and driven rotor along Y direction.</p>
</dd>
<dt>misalignment_angle<span class="classifier">float</span></dt><dd><p>Angular misalignment angle.</p>
</dd>
<dt>TD<span class="classifier">float</span></dt><dd><p>Driving torque.</p>
</dd>
<dt>TL<span class="classifier">float</span></dt><dd><p>Driven torque.</p>
</dd>
<dt>n1<span class="classifier">float</span></dt><dd><p>Node where the misalignment is ocurring.</p>
</dd>
<dt>speed<span class="classifier">float, pint.Quantity</span></dt><dd><p>Operational speed of the machine. Default unit is rad/s.</p>
</dd>
<dt>unbalance_magnitude<span class="classifier">array</span></dt><dd><p>Array with the unbalance magnitude. The unit is kg.m.</p>
</dd>
<dt>unbalance_phase<span class="classifier">array</span></dt><dd><p>Array with the unbalance phase. The unit is rad.</p>
</dd>
<dt>mis_type: string</dt><dd><p>String containing the misalignment type choosed. The avaible types are: parallel, by default; angular; combined.</p>
</dd>
<dt>print_progress<span class="classifier">bool</span></dt><dd><p>Set it True, to print the time iterations and the total time spent.
False by default.</p>
</dd>
</dl>
</dd>
<dt>In the case of coupling = “rigid”, <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs receives:</dt><dd><dl class="simple">
<dt>dt<span class="classifier">float</span></dt><dd><p>Time step.</p>
</dd>
<dt>tI<span class="classifier">float</span></dt><dd><p>Initial time.</p>
</dd>
<dt>tF<span class="classifier">float</span></dt><dd><p>Final time.</p>
</dd>
<dt>eCOUP<span class="classifier">float</span></dt><dd><p>Parallel misalignment offset between driving rotor and driven rotor along X direction.</p>
</dd>
<dt>TD<span class="classifier">float</span></dt><dd><p>Driving torque.</p>
</dd>
<dt>TL<span class="classifier">float</span></dt><dd><p>Driven torque.</p>
</dd>
<dt>n1<span class="classifier">float</span></dt><dd><p>Node where the misalignment is ocurring.</p>
</dd>
<dt>speed<span class="classifier">float, pint.Quantity</span></dt><dd><p>Operational speed of the machine. Default unit is rad/s.</p>
</dd>
<dt>unbalance_magnitude<span class="classifier">array</span></dt><dd><p>Array with the unbalance magnitude. The unit is kg.m.</p>
</dd>
<dt>unbalance_phase<span class="classifier">array</span></dt><dd><p>Array with the unbalance phase. The unit is rad.</p>
</dd>
<dt>print_progress<span class="classifier">bool</span></dt><dd><p>Set it True, to print the time iterations and the total time spent.
False by default.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ross.defects.misalignment</span> <span class="kn">import</span> <span class="n">misalignment_flex_parallel_example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">probe1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">probe2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">misalignment_flex_parallel_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">run_time_response</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">plot_dfft</span><span class="p">(</span><span class="n">probe</span><span class="o">=</span><span class="p">[</span><span class="n">probe1</span><span class="p">,</span> <span class="n">probe2</span><span class="p">],</span> <span class="n">range_freq</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">yaxis_type</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># fig.show()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_modal">
<code class="sig-name descname"><span class="pre">run_modal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_modal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_modal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run modal analysis.</p>
<p>Method to calculate eigenvalues and eigvectors for a given rotor system.
Tthe natural frequencies and dampings ratios are calculated for a given
rotor speed. It means that for each speed input there’s a different set of
eigenvalues and eigenvectors, hence, different natural frequencies and damping
ratios are returned.
This method will return a ModalResults object which stores all data generated
and also provides so methods for plotting.</p>
<dl class="simple">
<dt>Available plotting methods:</dt><dd><p>.plot_mode_2d()
.plot_mode_3d()</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>speed</strong><span class="classifier">float</span></dt><dd><p>Speed at which the eigenvalues and eigenvectors will be calculated.</p>
</dd>
<dt><strong>num_modes</strong><span class="classifier">int, optional</span></dt><dd><p>The number of eigenvalues and eigenvectors to be calculated using ARPACK.
If sparse=True, it determines the number of eigenvalues and eigenvectors
to be calculated. It must be smaller than Rotor.ndof - 1. It is not
possible to compute all eigenvectors of a matrix with ARPACK.
If sparse=False, num_modes does not have any effect over the method.
Default is 12.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, ARPACK is used to calculate a desired number (according to
num_modes) or eigenvalues and eigenvectors.
If False, scipy.linalg.eig() is used to calculate all the eigenvalues and
eigenvectors.
Default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">ross.ModalResults</span></dt><dd><p>For more information on attributes and methods available see:
<a class="reference internal" href="../results/ross.ModalResults.html#ross.ModalResults" title="ross.ModalResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">ross.ModalResults</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ross</span> <span class="k">as</span> <span class="nn">rs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modal</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_modal</span><span class="p">(</span><span class="n">speed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modal</span><span class="o">.</span><span class="n">wn</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([91.79655318, 96.28899977])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modal</span><span class="o">.</span><span class="n">wd</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([91.79655318, 96.28899977])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Plotting 3D mode shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mode1</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># First mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">modal</span><span class="o">.</span><span class="n">plot_mode_3d</span><span class="p">(</span><span class="n">mode1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Plotting 2D mode shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mode2</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Second mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">modal</span><span class="o">.</span><span class="n">plot_mode_2d</span><span class="p">(</span><span class="n">mode2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_rubbing">
<code class="sig-name descname"><span class="pre">run_rubbing</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">\*\*kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_rubbing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_rubbing" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an analyzes with rubbing.</p>
<p>Execute the rubbing defect and generates the rubbing object on the back-end.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs: dictionary</strong></dt><dd><dl class="simple">
<dt><a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs receives:</dt><dd><dl class="simple">
<dt>dt<span class="classifier">float</span></dt><dd><p>Time step.</p>
</dd>
<dt>tI<span class="classifier">float</span></dt><dd><p>Initial time.</p>
</dd>
<dt>tF<span class="classifier">float</span></dt><dd><p>Final time.</p>
</dd>
<dt>deltaRUB<span class="classifier">float</span></dt><dd><p>Distance between the housing and shaft surface.</p>
</dd>
<dt>kRUB<span class="classifier">float</span></dt><dd><p>Contact stiffness.</p>
</dd>
<dt>cRUB<span class="classifier">float</span></dt><dd><p>Contact damping.</p>
</dd>
<dt>miRUB<span class="classifier">float</span></dt><dd><p>Friction coefficient.</p>
</dd>
<dt>posRUB<span class="classifier">int</span></dt><dd><p>Node where the rubbing is ocurring.</p>
</dd>
<dt>speed<span class="classifier">float, pint.Quantity</span></dt><dd><p>Operational speed of the machine. Default unit is rad/s.</p>
</dd>
<dt>unbalance_magnitude<span class="classifier">array</span></dt><dd><p>Array with the unbalance magnitude. The unit is kg.m.</p>
</dd>
<dt>unbalance_phase<span class="classifier">array</span></dt><dd><p>Array with the unbalance phase. The unit is rad.</p>
</dd>
<dt>torque<span class="classifier">bool</span></dt><dd><p>Set it as True to consider the torque provided by the rubbing, by default False.</p>
</dd>
<dt>print_progress<span class="classifier">bool</span></dt><dd><p>Set it True, to print the time iterations and the total time spent, by default False.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ross.defects.rubbing</span> <span class="kn">import</span> <span class="n">rubbing_example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">probe1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">probe2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">rubbing_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">run_time_response</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">plot_dfft</span><span class="p">(</span><span class="n">probe</span><span class="o">=</span><span class="p">[</span><span class="n">probe1</span><span class="p">,</span> <span class="n">probe2</span><span class="p">],</span> <span class="n">range_freq</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">yaxis_type</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># fig.show()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_static">
<code class="sig-name descname"><span class="pre">run_static</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_static"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_static" title="Permalink to this definition">¶</a></dt>
<dd><p>Run static analysis.</p>
<p>Static analysis calculates free-body diagram, deformed shaft, shearing
force diagram and bending moment diagram.</p>
<dl class="simple">
<dt>Available plotting methods:</dt><dd><p>.plot_deformation()
.plot_bending_moment()
.plot_shearing_force()
.plot_free_body_diagram()</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>results: object</dt><dd><p>An instance of StaticResult class, which is used to create plots.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>Error raised if the rotor has no bearing elements.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shaft_weight: float</strong></dt><dd><p>Shaft total weight</p>
</dd>
<dt><strong>disk_forces_nodal</strong><span class="classifier">dict</span></dt><dd><p>Relates the static force at each node due to the weight of disks</p>
</dd>
<dt><strong>bearing_forces_nodal</strong><span class="classifier">dict</span></dt><dd><p>Relates the static force at each node due to the bearing reaction forces.</p>
</dd>
<dt><strong>bearing_forces_tag</strong><span class="classifier">dict</span></dt><dd><p>Indicates the reaction force exerted by each bearing.</p>
</dd>
<dt><strong>disk_forces_tag</strong><span class="classifier">dict</span></dt><dd><p>Indicates the force exerted by each disk.</p>
</dd>
<dt><strong>disp_y: array</strong></dt><dd><p>The shaft static displacement vector,</p>
</dd>
<dt><strong>Vx: array</strong></dt><dd><p>Shearing force vector</p>
</dd>
<dt><strong>Bm: array</strong></dt><dd><p>Bending moment vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_time_response">
<code class="sig-name descname"><span class="pre">run_time_response</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_time_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_time_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the time response.</p>
<p>This function will take a rotor object and calculate its time response
given a force and a time.</p>
<dl class="simple">
<dt>Available plotting methods:</dt><dd><p>.plot_1d()
.plot_2d()
.plot_3d()</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>speed</strong><span class="classifier">float</span></dt><dd><p>Rotor speed.</p>
</dd>
<dt><strong>F</strong><span class="classifier">array</span></dt><dd><p>Force array (needs to have the same number of rows as time array).
Each column corresponds to a dof and each row to a time.</p>
</dd>
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>Time array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">array</span></dt><dd><p>Array containing the time array, the system response, and the
time evolution of the state vector.
It will be returned if plot=False.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="mf">500.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">probe1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">rotor</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">[:,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">[:,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_time_response</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dof</span> <span class="o">=</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">yout</span><span class="p">[:,</span> <span class="n">dof</span><span class="p">]</span> 
<span class="go">array([ 0.00000000e+00,  1.86686693e-07,  8.39130663e-07, ...</span>
</pre></div>
</div>
<p># plot time response for a given probe:
&gt;&gt;&gt; fig1 = response.plot_1d(probe=[probe1])</p>
<p># plot orbit response - plotting 2D nodal orbit:
&gt;&gt;&gt; fig2 = response.plot_2d(node=node)</p>
<p># plot orbit response - plotting 3D orbits - full rotor model:
&gt;&gt;&gt; fig3 = response.plot_3d()</p>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_ucs">
<code class="sig-name descname"><span class="pre">run_ucs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">stiffness_range=None</span></em>, <em class="sig-param"><span class="pre">num_modes=16</span></em>, <em class="sig-param"><span class="pre">num=20</span></em>, <em class="sig-param"><span class="pre">fig=None</span></em>, <em class="sig-param"><span class="pre">synchronous=False</span></em>, <em class="sig-param"><span class="pre">\*\*kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_ucs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_ucs" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Undamped Critical Speeds analyzes.</p>
<p>This method will run the undamped critical speed analyzes for a given range
of stiffness values. If the range is not provided, the bearing
stiffness at rated speed will be used to create a range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stiffness_range</strong><span class="classifier">tuple, optional</span></dt><dd><p>Tuple with (start, end) for stiffness range.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int</span></dt><dd><p>Number of steps in the range.
Default is 20.</p>
</dd>
<dt><strong>num_modes</strong><span class="classifier">int, optional</span></dt><dd><p>Number of modes to be calculated. This uses scipy.sparse.eigs method.
Default is 16.</p>
</dd>
<dt><strong>synchronous</strong><span class="classifier">bool</span></dt><dd><p>If True a synchronous analysis is carried out and the frequency of
the first forward model will be equal to the speed.
Default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.run_unbalance_response">
<code class="sig-name descname"><span class="pre">run_unbalance_response</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalance_magnitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalance_phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.run_unbalance_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.run_unbalance_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Unbalanced response for a mdof system.</p>
<p>This method returns the unbalanced response for a mdof system
given magnitide and phase of the unbalance, the node where it’s
applied and a frequency range.</p>
<dl class="simple">
<dt>Available plotting methods:</dt><dd><p>.plot()
.plot_magnitude()
.plot_phase()
.plot_polar_bode()
.plot_deflected_shape()
.plot_bending_moment()
.plot_deflected_shape_3d()
.plot_deflected_shape_2d()</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>node</strong><span class="classifier">list, int</span></dt><dd><p>Node where the unbalance is applied.</p>
</dd>
<dt><strong>unbalance_magnitude</strong><span class="classifier">list, float, pint.Quantity</span></dt><dd><p>Unbalance magnitude (kg.m).</p>
</dd>
<dt><strong>unbalance_phase</strong><span class="classifier">list, float, pint.Quantity</span></dt><dd><p>Unbalance phase (rad).</p>
</dd>
<dt><strong>frequency</strong><span class="classifier">list, float, pint.Quantity</span></dt><dd><p>Array with the desired range of frequencies (rad/s).</p>
</dd>
<dt><strong>modes</strong><span class="classifier">list, optional</span></dt><dd><p>Modes that will be used to calculate the frequency response
(all modes will be used if a list is not given).</p>
</dd>
<dt><strong>cluster_points</strong><span class="classifier">bool, optional</span></dt><dd><p>boolean to activate the automatic frequency spacing method. If True, the
method uses _clustering_points() to create an speed_range.
Default is False</p>
</dd>
<dt><strong>num_points</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points generated per critical speed.
The method set the same number of points for slightly less and slightly
higher than the natural circular frequency. It means there’ll be num_points
greater and num_points smaller than a given critical speed.
num_points may be between 2 and 12. Anything above this range defaults
to 10 and anything below this range defaults to 4.
The default is 10.</p>
</dd>
<dt><strong>num_modes</strong></dt><dd><p>The number of eigenvalues and eigenvectors to be calculated using ARPACK.
It also defines the range for the output array, since the method generates
points only for the critical speed calculated by run_critical_speed().
Default is 12.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance (relative) for termination. Applied to scipy.optimize.newton to
calculate the approximated critical speeds.
Default is 0.005 (0.5%).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>forced_response</strong><span class="classifier">object</span></dt><dd><p>An instance of ForcedResponseResult class, which is used to post-process
results. Attributes stored:
forced_resp : array</p>
<blockquote>
<div><p>Array with the forced response for each node for each frequency.</p>
</div></blockquote>
<dl class="simple">
<dt>speed_range<span class="classifier">array</span></dt><dd><p>Array with the frequencies.</p>
</dd>
<dt>velc_resp<span class="classifier">array</span></dt><dd><p>Array with the velocity response for each node for each frequency.</p>
</dd>
<dt>accl_resp<span class="classifier">array</span></dt><dd><p>Array with the acceleration response for each node for each frequency.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ross</span> <span class="k">as</span> <span class="nn">rs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_unbalance_response</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">unbalance_magnitude</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">unbalance_phase</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">frequency</span><span class="o">=</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>Return the response amplitude
&gt;&gt;&gt; abs(response.forced_resp) # doctest: +ELLIPSIS
array([[0.00000000e+00, 5.06073311e-04, 2.10044826e-03, …</p>
<p>Return the response phase
&gt;&gt;&gt; np.angle(response.forced_resp) # doctest: +ELLIPSIS
array([[ 0.00000000e+00, …</p>
<p>Using clustered points option.
Set <cite>cluster_points=True</cite> and choose how many modes the method must search and
how many points to add just before and after each critical speed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response2</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">run_unbalance_response</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">node</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">unbalance_magnitude</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">unbalance_phase</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cluster_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">5</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response2</span><span class="o">.</span><span class="n">speed_range</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(61,)</span>
</pre></div>
</div>
<p>plot unbalance response:
&gt;&gt;&gt; probe_node = 3
&gt;&gt;&gt; probe_angle = np.pi / 2
&gt;&gt;&gt; probe_tag = “my_probe”  # optional
&gt;&gt;&gt; fig = response.plot(probe=[(probe_node, probe_angle, probe_tag)])</p>
<p>plot response for major or minor axis:
&gt;&gt;&gt; probe_node = 3
&gt;&gt;&gt; probe_angle = “major”   # for major axis
&gt;&gt;&gt; # probe_angle = “minor” # for minor axis
&gt;&gt;&gt; probe_tag = “my_probe”  # optional
&gt;&gt;&gt; fig = response.plot(probe=[(probe_node, probe_angle, probe_tag)])</p>
<p>To plot velocity and acceleration responses, you must change amplitude_units
from “[length]” units to “[length]/[time]” or “[length]/[time] ** 2” respectively
Plotting velocity response
&gt;&gt;&gt; fig = response.plot(
…     probe=[(probe_node, probe_angle)],
…     amplitude_units=”m/s”
… )</p>
<p>Plotting acceleration response
&gt;&gt;&gt; fig = response.plot(
…     probe=[(probe_node, probe_angle)],
…     amplitude_units=”m/s**2”
… )</p>
<p>Plotting deflected shape configuration
Speed value must be in speed_range.
&gt;&gt;&gt; value = 600
&gt;&gt;&gt; fig = response.plot_deflected_shape(speed=value)</p>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.save">
<code class="sig-name descname"><span class="pre">save</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.save"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the rotor to a .toml file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file</strong><span class="classifier">str or pathlib.Path</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">tempdir</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create path for temporary file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">tempdir</span><span class="p">)</span> <span class="o">/</span> <span class="s1">&#39;rotor.toml&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.save_mat">
<code class="sig-name descname"><span class="pre">save_mat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.save_mat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.save_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Save matrices and rotor model to a .mat file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file</strong><span class="classifier">str, pathlib.Path</span></dt><dd></dd>
<dt><strong>speed: float</strong></dt><dd><p>Rotor speed.</p>
</dd>
<dt><strong>frequency: float, optional</strong></dt><dd><p>Excitation frequency.
Default is rotor speed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">tempdir</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create path for temporary file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">tempdir</span><span class="p">)</span> <span class="o">/</span> <span class="s1">&#39;new_matrices&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span><span class="o">.</span><span class="n">save_mat</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">speed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.summary">
<code class="sig-name descname"><span class="pre">summary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the rotor summary.</p>
<p>This functioncreates a summary of the main parameters and attributes of the
rotor model. The data is presented in a table format.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>results</strong><span class="classifier">ross.SummaryResults class</span></dt><dd><p>An instance of SumarryResults class to build the summary table</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># to display the plot use the command:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># show(table)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.time_response">
<code class="sig-name descname"><span class="pre">time_response</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.time_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.time_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Time response for a rotor.</p>
<p>This method returns the time response for a rotor
given a force, time and initial conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>F</strong><span class="classifier">array</span></dt><dd><p>Force array (needs to have the same length as time array).</p>
</dd>
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>Time array. (must have the same length than lti.B matrix)</p>
</dd>
<dt><strong>ic</strong><span class="classifier">array, optional</span></dt><dd><p>The initial conditions on the state vector (zero by default).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>Time values for the output.</p>
</dd>
<dt><strong>yout</strong><span class="classifier">array</span></dt><dd><p>System response.</p>
</dd>
<dt><strong>xout</strong><span class="classifier">array</span></dt><dd><p>Time evolution of the state vector.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span> <span class="o">=</span> <span class="n">rotor_example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">rotor</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotor</span><span class="o">.</span><span class="n">time_response</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> 
<span class="go">(array([0.        , 0.18518519, 0.37037037, ...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ross.Rotor.transfer_matrix">
<code class="sig-name descname"><span class="pre">transfer_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">speed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ross/rotor_assembly.html#Rotor.transfer_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ross.Rotor.transfer_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the fer matrix for the frequency response function (FRF).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">matrix</span></dt><dd><p>System transfer matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020, Team ROSS.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br/>
    </p>
  </div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-157532410-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-157532410-1');
</script>

  </body>
</html>